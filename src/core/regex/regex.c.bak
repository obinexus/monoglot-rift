/**
#include "core/regex/regex.h
core/automaton/regex.h"
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include "core/errors/error.h"
#include "core/errors/error.h"
#include "core/errors/error.h"
#include "core/errors/error.h"
#include "core/errors/error.h"
#include "core/errors/error.h"
#include "core/errors/error.h"
#include "core/errors/error.h"
#include "core/errors/error.h"
#include "core/errors/error.h"
#include "core/errors/error.h"
#include "core/errors/regex_error.h"
#include "core/errors/regex_error.h"
#include "core/errors/regex_error.h"
#include "core/errors/regex_error.h"
#include "core/errors/regex_error.h"
#include "core/errors/regex_error.h"
#include "core/errors/regex_error.h"
#include "core/errors/regex_error.h"
#include "core/errors/regex_error.h"
#include "core/errors/regex_error.h"
#include "core/errors/regex_error.h"
#include "core/errors/regex_error.h"
#include "core/memory/memory.h"
#include "core/memory/memory.h"
#include "core/memory/memory.h"
#include "core/memory/memory.h"
#include "core/memory/memory.h"
#include "core/memory/memory.h"
#include "core/memory/memory.h"
#include "core/memory/memory.h"
#include "core/memory/memory.h"
#include "core/memory/memory.h"
#include "core/memory/memory.h"
#include "core/memory/memory.h"
 * @file regex.c
 * @brief Implementation of standard regex integration for the LibRift automaton engine
 *
 * This file implements the integration with the standard regex library for pattern
 * matching within the automaton component of the LibRift regex engine.
 *
 * @copyright Copyright (c) 2025 LibRift Project
 * @license MIT License
 */




/**
 * @brief Compile a regex pattern
 *
 * This function is a thin wrapper around regcomp with some additional
 * error handling specific to the LibRift engine.
 */
int
rift_regex_compile(const char *pattern, int cflags, regex_t *preg)
{
    if (!pattern || !preg) {
        return REG_BADPAT;
    }

    return regcomp(preg, pattern, cflags);
}

/**
 * @brief Execute a regex pattern against a string
 *
 * This function is a thin wrapper around regexec with some additional
 * error handling specific to the LibRift engine.
 */
int
rift_regex_exec(const regex_t *preg, const char *string, size_t nmatch, regmatch_t *pmatch,
                int eflags)
{
    if (!preg || !string) {
        return REG_NOMATCH;
    }

    return regexec(preg, string, nmatch, pmatch, eflags);
}

/**
 * @brief Free resources associated with a compiled regex pattern
 *
 * This function is a thin wrapper around regfree.
 */
void
rift_regex_free(regex_t *preg)
{
    if (preg) {
        regfree(preg);
    }
}

/**
 * @brief Get error message for a regex error code
 *
 * This function is a thin wrapper around regerror.
 */
size_t
rift_regex_error(int errcode, const regex_t *preg, char *errbuf, size_t errbuf_size)
{
    if (!errbuf || errbuf_size == 0) {
        return 0;
    }

    return regerror(errcode, preg, errbuf, errbuf_size);
}

/**
 * @brief Check if a string matches a pattern
 *
 * This function compiles the pattern, executes it against the string,
 * and cleans up the resources afterwards.
 */
bool
rift_regex_matches(const char *pattern, const char *string, int flags)
{
    if (!pattern || !string) {
        return false;
    }

    regex_t regex;
    int result = rift_regex_compile(pattern, flags, &regex);
    if (result != 0) {
        return false;
    }

    result = rift_regex_exec(&regex, string, 0, NULL, 0);
    rift_regex_free(&regex);

    return (result == 0);
}

/**
 * @brief Get the part of a string that matches a pattern
 *
 * This function compiles the pattern, executes it against the string,
 * and returns the start and end indices of the match.
 */
bool
rift_regex_find(const char *pattern, const char *string, size_t *start, size_t *end, int flags)
{
    if (!pattern || !string || !start || !end) {
        return false;
    }

    regex_t regex;
    int result = rift_regex_compile(pattern, flags, &regex);
    if (result != 0) {
        return false;
    }

    regmatch_t match;
    result = rift_regex_exec(&regex, string, 1, &match, 0);

    if (result == 0) {
        *start = match.rm_so;
        *end = match.rm_eo;
    }

    rift_regex_free(&regex);
    return (result == 0);
}

/**
 * @brief Replace matches of a pattern in a string
 *
 * This function compiles the pattern, finds all matches, and replaces them
 * with the replacement string.
 */
bool
rift_regex_replace(const rift_regex_pattern_t *pattern, const char *input, const char *replacement,
                   char *result, size_t result_size, size_t *replacements)
{
    if (!pattern || !input || !replacement || !result || result_size == 0 || !replacements) {
        return false;
    }

    regex_t regex;
    // We're assuming the pattern contains a compiled regex or can be accessed
    // through the pattern object; implementation needs to be adjusted based on
    // the actual structure of rift_regex_pattern_t

    const char *current = input;
    char *result_ptr = result;
    size_t remaining = result_size - 1; /* Leave room for null terminator */
    regmatch_t match;
    size_t count = 0;

    while (remaining > 0 && rift_regex_exec(&regex, current, 1, &match, 0) == 0) {
        /* Copy text before the match */
        size_t prefix_len = match.rm_so;
        if (prefix_len > remaining) {
            prefix_len = remaining;
        }
        memcpy(result_ptr, current, prefix_len);
        result_ptr += prefix_len;
        remaining -= prefix_len;

        /* Copy the replacement */
        size_t replacement_len = strlen(replacement);
        if (replacement_len > remaining) {
            replacement_len = remaining;
        }
        memcpy(result_ptr, replacement, replacement_len);
        result_ptr += replacement_len;
        remaining -= replacement_len;

        /* Move past the match in the source string */
        current += match.rm_eo;
        count++;

        /* If we've run out of space or reached end of string, break */
        if (remaining == 0 || *current == '\0') {
            break;
        }
    }

    /* Copy any remaining text */
    if (remaining > 0) {
        size_t remaining_len = strlen(current);
        if (remaining_len > remaining) {
            remaining_len = remaining;
        }
        memcpy(result_ptr, current, remaining_len);
        result_ptr += remaining_len;
        remaining -= remaining_len;
    }

    /* Ensure null termination */
    *result_ptr = '\0';

    rift_regex_free(&regex);
    *replacements = count;
    return true;
}

/**
 * @brief Check if a pattern is valid
 *
 * This function attempts to compile the pattern and returns true if
 * compilation succeeds.
 */
bool
rift_regex_is_valid(const char *pattern, int flags)
{
    if (!pattern) {
        return false;
    }

    regex_t regex;
    int result = rift_regex_compile(pattern, flags, &regex);

    if (result == 0) {
        rift_regex_free(&regex);
        return true;
    }

    return false;
}
bool
rift_regex_error_init(rift_regex_error_t *error)
{
    if (!error) {
        return false;
    }

    error->code = RIFT_REGEX_ERROR_NONE;
    error->position = 0;
    return true;
}

/**
 * @brief Get a descriptive string for a regex error
 *
 * This function returns a human-readable description of the error
 * based on the error code in the rift_regex_error_t structure.
 *
 * @param error The regex error structure
 * @return A descriptive string explaining the error
 */
const char *
rift_regex_get_error_string(rift_regex_error_t error)
{
    switch (error.code) {
    case RIFT_REGEX_ERROR_NONE:
        return "No error";
    case RIFT_REGEX_ERROR_INTERNAL:
        return "Internal regex engine error";
    case RIFT_REGEX_ERROR_INVALID_PARAMETER:
        return "Invalid parameter passed to regex function";
    case RIFT_REGEX_ERROR_MEMORY:
        return "Memory allocation failed during regex operation";
    case RIFT_REGEX_ERROR_INVALID_AUTOMATON:
        return "Invalid automaton structure in regex engine";
    case RIFT_REGEX_ERROR_EMPTY_AUTOMATON:
        return "Empty automaton encountered in regex processing";
    case RIFT_REGEX_ERROR_SYNTAX:
        return "Syntax error in regular expression pattern";
    case RIFT_REGEX_ERROR_UNSUPPORTED_FEATURE:
        return "Unsupported regex feature or construct";
    case RIFT_REGEX_ERROR_INVALID_QUANTIFIER:
        return "Invalid or malformed quantifier in regex pattern";
    case RIFT_REGEX_ERROR_INVALID_ESCAPE:
        return "Invalid escape sequence in regex pattern";
    case RIFT_REGEX_ERROR_INVALID_CHARACTER_CLASS:
        return "Invalid character class in regex pattern";
    case RIFT_REGEX_ERROR_INVALID_BACKREFERENCE:
        return "Invalid backreference in regex pattern";
    case RIFT_REGEX_ERROR_UNBALANCED_PARENTHESES:
        return "Unbalanced parentheses in regex pattern";
    case RIFT_REGEX_ERROR_UNBALANCED_BRACKETS:
        return "Unbalanced brackets in regex pattern";
    case RIFT_REGEX_ERROR_TRAILING_BACKSLASH:
        return "Trailing backslash in regex pattern";
    case RIFT_REGEX_ERROR_BACKTRACKING_LIMIT:
        return "Backtracking limit exceeded during regex matching";
    case RIFT_REGEX_ERROR_TIMEOUT:
        return "Regex operation timed out";
    case RIFT_REGEX_ERROR_UNSUPPORTED_OPERATION:
        return "Unsupported regex operation requested";
    case RIFT_REGEX_ERROR_UNEXPECTED_TOKEN:
        return "Unexpected token encountered during regex parsing";
    case RIFT_REGEX_ERROR_LIMIT_EXCEEDED:
        return "Resource limit exceeded during regex processing";
    case RIFT_REGEX_ERROR_BUFFER_OVERFLOW:
        return "Buffer overflow occurred during regex operation";
    default:
        return "Unknown regex error";
    }
}
