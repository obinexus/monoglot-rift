ommand/ast_command.h"/a #include "core/errors/regex_error.h"
#include "cli/command/ast_command.h"
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "core/parser/ast.h"
#include "core/parser/ast.h"
#include "core/parser/ast.h"
#include "core/parser/ast.h"
#include "core/parser/ast.h"
#include "core/parser/ast.h"
#include "core/parser/ast.h"
#include "core/parser/ast.h"
#include "core/parser/ast.h"
#include "core/parser/ast.h"
#include "core/parser/ast.h"
#include "core/parser/ast.h"
#include "core/parser/parser.h"
#include "core/parser/parser.h"
#include "core/parser/parser.h"
#include "core/parser/parser.h"
#include "core/parser/parser.h"
#include "core/parser/parser.h"
#include "core/parser/parser.h"
#include "core/parser/parser.h"
#include "core/parser/parser.h"
#include "core/parser/parser.h"
#include "core/parser/parser.h"
#include "core/parser/parser.h"
#include "core/syntax/parser.h"
#include "core/syntax/parser.h"
#include "core/syntax/parser.h"
#include "core/syntax/parser.h"
#include "core/syntax/parser.h"
#include "core/syntax/parser.h"
#include "core/syntax/parser.h"
#include "core/syntax/parser.h"
#include "core/syntax/parser.h"
#include "core/syntax/parser.h"
#include "core/syntax/parser.h"
#include "librift/cli/commands/ast_command.h"
#include "librift/parser/ast.h"
#include "librift/parser/parser.h"
#include "librift/utils/file_utils.h"
#include "librift/utils/memory_utils.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
/**
 * @file ast_command.c
 * @brief AST command implementation for LibRift CLI
 *
 * This file implements the AST command, which processes input files or
 * parse trees and generates Abstract Syntax Trees.
 *
 * @copyright Copyright (c) 2025 LibRift Project
 * @license MIT License
 */




ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
/**
 * @brief Create a new AST command
 *
 * @return A new AST command instance or NULL on failure
 */
rift_command_t *
rift_ast_command_create(void)
{
    rift_ast_command_t *cmd = (rift_ast_command_t *)rift_malloc(sizeof(rift_ast_command_t));
    if (!cmd) {
        return NULL;
    }

    /* Initialize command structure */
    cmd->base.type = RIFT_COMMAND_AST;
    cmd->verbose = false;
    cmd->quiet = false;

    /* Initialize options with defaults */
    cmd->options.input_file = NULL;
    cmd->options.output_file = NULL;
    cmd->options.format = NULL;
    cmd->options.transform_file = NULL;
    cmd->options.optimize = false;
    cmd->options.parse_tree_file = NULL;
    cmd->options.visualize = false;
    cmd->options.flags = 0;

    return (rift_command_t *)cmd;
}

ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
/**
 * @brief Get the type of a command
 *
 * @param command The command
 * @return The command type
 */
rift_command_type_t
rift_command_get_type(const rift_command_t *command)
{
    if (!command) {
        return RIFT_COMMAND_UNKNOWN;
    }

    const rift_ast_command_t *cmd = (const rift_ast_command_t *)command;
    return cmd->base.type;
}

ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
/**
 * @brief Set verbose flag for a command
 *
 * @param command The command
 * @param verbose Whether to enable verbose output
 */
void
rift_command_set_verbose(rift_command_t *command, bool verbose)
{
    if (!command) {
        return;
    }

    rift_ast_command_t *cmd = (rift_ast_command_t *)command;
    cmd->verbose = verbose;
}

ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
/**
 * @brief Set quiet flag for a command
 *
 * @param command The command
 * @param quiet Whether to enable quiet mode
 */
void
rift_command_set_quiet(rift_command_t *command, bool quiet)
{
    if (!command) {
        return;
    }

    rift_ast_command_t *cmd = (rift_ast_command_t *)command;
    cmd->quiet = quiet;
}

ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
/**
 * @brief Get the options for an AST command
 *
 * @param command The AST command
 * @return Pointer to the AST options
 */
rift_ast_options_t *
rift_ast_command_get_options(rift_command_t *command)
{
    if (!command || rift_command_get_type(command) != RIFT_COMMAND_AST) {
        return NULL;
    }

    rift_ast_command_t *cmd = (rift_ast_command_t *)command;
    return &cmd->options;
}

ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
/**
 * @brief Set the options for an AST command
 *
 * @param command The AST command
 * @param options The options to set
 * @return true if successful, false otherwise
 */
bool
rift_ast_command_set_options(rift_command_t *command, const rift_ast_options_t *options)
{
    if (!command || rift_command_get_type(command) != RIFT_COMMAND_AST || !options) {
        return false;
    }

    rift_ast_command_t *cmd = (rift_ast_command_t *)command;

    /* Free existing options if present */
    if (cmd->options.input_file) {
        rift_free(cmd->options.input_file);
    }

    if (cmd->options.output_file) {
        rift_free(cmd->options.output_file);
    }

    if (cmd->options.format) {
        rift_free(cmd->options.format);
    }

    if (cmd->options.transform_file) {
        rift_free(cmd->options.transform_file);
    }

    if (cmd->options.parse_tree_file) {
        rift_free(cmd->options.parse_tree_file);
    }

    /* Copy options */
    cmd->options.optimize = options->optimize;
    cmd->options.visualize = options->visualize;
    cmd->options.flags = options->flags;

    /* Copy input file if present */
    if (options->input_file) {
        cmd->options.input_file = rift_strdup(options->input_file);
        if (!cmd->options.input_file) {
            return false;
        }
    } else {
        cmd->options.input_file = NULL;
    }

    /* Copy output file if present */
    if (options->output_file) {
        cmd->options.output_file = rift_strdup(options->output_file);
        if (!cmd->options.output_file) {
            rift_free(cmd->options.input_file);
            cmd->options.input_file = NULL;
            return false;
        }
    } else {
        cmd->options.output_file = NULL;
    }

    /* Copy format if present */
    if (options->format) {
        cmd->options.format = rift_strdup(options->format);
        if (!cmd->options.format) {
            rift_free(cmd->options.input_file);
            rift_free(cmd->options.output_file);
            cmd->options.input_file = NULL;
            cmd->options.output_file = NULL;
            return false;
        }
    } else {
        cmd->options.format = NULL;
    }

    /* Copy transform file if present */
    if (options->transform_file) {
        cmd->options.transform_file = rift_strdup(options->transform_file);
        if (!cmd->options.transform_file) {
            rift_free(cmd->options.input_file);
            rift_free(cmd->options.output_file);
            rift_free(cmd->options.format);
            cmd->options.input_file = NULL;
            cmd->options.output_file = NULL;
            cmd->options.format = NULL;
            return false;
        }
    } else {
        cmd->options.transform_file = NULL;
    }

    /* Copy parse tree file if present */
    if (options->parse_tree_file) {
        cmd->options.parse_tree_file = rift_strdup(options->parse_tree_file);
        if (!cmd->options.parse_tree_file) {
            rift_free(cmd->options.input_file);
            rift_free(cmd->options.output_file);
            rift_free(cmd->options.format);
            rift_free(cmd->options.transform_file);
            cmd->options.input_file = NULL;
            cmd->options.output_file = NULL;
            cmd->options.format = NULL;
            cmd->options.transform_file = NULL;
            return false;
        }
    } else {
        cmd->options.parse_tree_file = NULL;
    }

    return true;
}

ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
/**
 * @brief Parse command-specific arguments
 *
 * @param command The command
 * @param argc Argument count
 * @param argv Argument vector
 * @return true if parsing was successful, false otherwise
 */
bool
rift_command_parse_args(rift_command_t *command, int argc, char *argv[])
{
    if (!command) {
        return false;
    }

    rift_ast_command_t *cmd = (rift_ast_command_t *)command;

    /* Must have at least an input file */
    if (argc < 1) {
        if (!cmd->quiet) {
            fprintf(stderr, "Error: No input file specified.\n");
        }
        return false;
    }

    /* Set the input file */
    cmd->options.input_file = rift_strdup(argv[0]);
    if (!cmd->options.input_file) {
        fprintf(stderr, "Error: Failed to allocate memory for input file\n");
        return false;
    }

    /* Parse additional options */
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--output") == 0 || strcmp(argv[i], "-o") == 0) {
            /* Output file */
            if (i + 1 < argc) {
                cmd->options.output_file = rift_strdup(argv[i + 1]);
                if (!cmd->options.output_file) {
                    fprintf(stderr, "Error: Failed to allocate memory for output file\n");
                    return false;
                }
                i++; /* Skip the argument value */
            } else {
                if (!cmd->quiet) {
                    fprintf(stderr, "Error: Missing argument for --output option.\n");
                }
                return false;
            }
        } else if (strcmp(argv[i], "--format") == 0) {
            /* Output format */
            if (i + 1 < argc) {
                if (strcmp(argv[i + 1], "json") == 0 || strcmp(argv[i + 1], "dot") == 0 ||
                    strcmp(argv[i + 1], "text") == 0) {
                    cmd->options.format = rift_strdup(argv[i + 1]);
                    if (!cmd->options.format) {
                        fprintf(stderr, "Error: Failed to allocate memory for format\n");
                        return false;
                    }
                } else {
                    fprintf(stderr, "Error: Invalid format: %s. Must be json, dot, or text.\n",
                            argv[i + 1]);
                    return false;
                }
                i++; /* Skip the argument value */
            } else {
                if (!cmd->quiet) {
                    fprintf(stderr, "Error: Missing argument for --format option.\n");
                }
                return false;
            }
        } else if (strcmp(argv[i], "--transform") == 0) {
            /* Transformation file */
            if (i + 1 < argc) {
                cmd->options.transform_file = rift_strdup(argv[i + 1]);
                if (!cmd->options.transform_file) {
                    fprintf(stderr, "Error: Failed to allocate memory for transform file\n");
                    return false;
                }
                i++; /* Skip the argument value */
            } else {
                if (!cmd->quiet) {
                    fprintf(stderr, "Error: Missing argument for --transform option.\n");
                }
                return false;
            }
        } else if (strcmp(argv[i], "--optimize") == 0) {
            /* Enable optimization */
            cmd->options.optimize = true;
        } else if (strcmp(argv[i], "--parse-tree") == 0) {
            /* Parse tree file */
            if (i + 1 < argc) {
                cmd->options.parse_tree_file = rift_strdup(argv[i + 1]);
                if (!cmd->options.parse_tree_file) {
                    fprintf(stderr, "Error: Failed to allocate memory for parse tree file\n");
                    return false;
                }
                i++; /* Skip the argument value */
            } else {
                if (!cmd->quiet) {
                    fprintf(stderr, "Error: Missing argument for --parse-tree option.\n");
                }
                return false;
            }
        } else if (strcmp(argv[i], "--visualize") == 0) {
            /* Enable visualization */
            cmd->options.visualize = true;
        } else {
            /* Unknown option */
            if (!cmd->quiet) {
                fprintf(stderr, "Warning: Unknown option '%s' ignored.\n", argv[i]);
            }
        }
    }

    /* If no format is specified, use "text" as default */
    if (!cmd->options.format) {
        cmd->options.format = rift_strdup("text");
        if (!cmd->options.format) {
            fprintf(stderr, "Error: Failed to allocate memory for default format\n");
            return false;
        }
    }

    return true;
}

ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
/**
 * @brief Execute the AST command
 *
 * @param command The command
 * @return 0 on success, non-zero on failure
 */
int
rift_command_execute(rift_command_t *command)
{
    if (!command) {
        return 1;
    }

    rift_ast_command_t *cmd = (rift_ast_command_t *)command;

    /* Validate options */
    if (!cmd->options.input_file) {
        fprintf(stderr, "Error: No input file specified\n");
        return 1;
    }

    /* Print what we're doing */
    if (cmd->verbose && !cmd->quiet) {
        printf("Building AST from: %s\n", cmd->options.input_file);
        if (cmd->options.parse_tree_file) {
            printf("Using parse tree file: %s\n", cmd->options.parse_tree_file);
        }
        printf("Output format: %s\n", cmd->options.format);
        if (cmd->options.output_file) {
            printf("Output file: %s\n", cmd->options.output_file);
        }
        if (cmd->options.transform_file) {
            printf("Transform file: %s\n", cmd->options.transform_file);
        }
        printf("Optimize: %s\n", cmd->options.optimize ? "yes" : "no");
        printf("Visualize: %s\n", cmd->options.visualize ? "yes" : "no");
    }

    /* Create parser */
    rift_regex_parser_t *parser = rift_regex_parser_create(cmd->options.flags, false);
    if (!parser) {
        fprintf(stderr, "Error: Failed to create parser\n");
        return 1;
    }

    /* Parse the input file or parse tree */
    rift_regex_ast_t *ast = NULL;
    rift_regex_error_t error;

    if (cmd->options.parse_tree_file) {
        /* Load the parse tree from file (this would be implemented in a real system) */
        if (cmd->verbose && !cmd->quiet) {
            printf("Loading parse tree from file: %s\n", cmd->options.parse_tree_file);
        }

        /* Placeholder: In a real implementation, we would load the parse tree */
        fprintf(stderr, "Error: Loading parse tree from file not implemented yet\n");
        rift_regex_parser_free(parser);
        return 1;
    } else {
        /* Read the input file */
        char *input_content = rift_read_file(cmd->options.input_file);
        if (!input_content) {
            fprintf(stderr, "Error: Failed to read input file: %s\n", cmd->options.input_file);
            rift_regex_parser_free(parser);
            return 1;
        }

        /* Parse the input */
        ast = rift_regex_parser_parse(parser, input_content);
        rift_free(input_content);

        if (!ast) {
            error = rift_regex_parser_get_error(parser);
            fprintf(stderr, "Error: Parsing failed: %s\n", error.message);
            rift_regex_parser_free(parser);
            return 1;
        }
    }

    /* Apply transformations if specified */
    if (cmd->options.transform_file) {
        if (cmd->verbose && !cmd->quiet) {
            printf("Applying transformations from: %s\n", cmd->options.transform_file);
        }

        /* Placeholder: In a real implementation, we would apply transformations */
        fprintf(stdout, "Notice: Transformation application not implemented yet\n");
    }

    /* Apply optimizations if requested */
    if (cmd->options.optimize) {
        if (cmd->verbose && !cmd->quiet) {
            printf("Applying AST optimizations\n");
        }

        /* Placeholder: In a real implementation, we would apply optimizations */
        bool optimized = rift_regex_ast_validate(ast);
        if (!optimized) {
            fprintf(stderr, "Warning: Optimization failed, AST may be invalid\n");
        }
    }

    /* Generate output */
    char *ast_output = NULL;
    if (strcmp(cmd->options.format, "text") == 0) {
        ast_output = rift_regex_ast_to_string(ast);
    } else if (strcmp(cmd->options.format, "json") == 0) {
        /* Placeholder: In a real implementation, we would generate JSON */
        fprintf(stderr, "Error: JSON output format not implemented yet\n");
        rift_regex_ast_free(ast);
        rift_regex_parser_free(parser);
        return 1;
    } else if (strcmp(cmd->options.format, "dot") == 0) {
        /* Placeholder: In a real implementation, we would generate DOT */
        fprintf(stderr, "Error: DOT output format not implemented yet\n");
        rift_regex_ast_free(ast);
        rift_regex_parser_free(parser);
        return 1;
    }

    if (!ast_output) {
        fprintf(stderr, "Error: Failed to generate AST output\n");
        rift_regex_ast_free(ast);
        rift_regex_parser_free(parser);
        return 1;
    }

    /* Write output to file or stdout */
    if (cmd->options.output_file) {
        if (!rift_write_file(cmd->options.output_file, ast_output)) {
            fprintf(stderr, "Error: Failed to write output to file: %s\n",
                    cmd->options.output_file);
            rift_free(ast_output);
            rift_regex_ast_free(ast);
            rift_regex_parser_free(parser);
            return 1;
        }

        if (!cmd->quiet) {
            printf("AST written to: %s\n", cmd->options.output_file);
        }
    } else {
        /* Print to stdout */
        printf("%s\n", ast_output);
    }

    /* Generate visualization if requested */
    if (cmd->options.visualize) {
        if (cmd->verbose && !cmd->quiet) {
            printf("Generating AST visualization\n");
        }

        /* Placeholder: In a real implementation, we would generate visualization */
        fprintf(stdout, "Notice: AST visualization not implemented yet\n");
    }

    /* Clean up */
    rift_free(ast_output);
    rift_regex_ast_free(ast);
    rift_regex_parser_free(parser);

    return 0;
}

ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
/**
 * @brief Get help information for a command
 *
 * @param command The command
 * @return Help string for the command
 */
const char *
rift_command_get_help(const rift_command_t *command)
{
    if (!command) {
        return "Error: Invalid command";
    }

    rift_command_type_t type = rift_command_get_type(command);

    if (type == RIFT_COMMAND_AST) {
        return "ast <input-file> [options]\n"
               "\n"
               "Build an Abstract Syntax Tree (AST) from a source file or parse tree.\n"
               "\n"
               "Arguments:\n"
               "  <input-file>                 Source file or parse tree file\n"
               "\n"
               "Options:\n"
               "  --output, -o <file>          Save AST to a file\n"
               "  --format <json|dot|text>     Output format (default: text)\n"
               "  --transform <file>           Apply transformations from file\n"
               "  --optimize                   Apply AST optimizations\n"
               "  --parse-tree <file>          Use parse tree from file\n"
               "  --visualize                  Generate graphical AST view\n"
               "\n"
               "Examples:\n"
               "  rift ast source.rf --output ast.txt\n"
               "  rift ast parse_tree.json --parse-tree --format dot --visualize\n"
               "  rift ast pattern.rf --transform optimizations.json --optimize";
    }

    return "Error: Unknown command type";
}

ommand/ast_command.h"/a #include "core/errors/regex_error.h"
ommand/ast_command.h"/a #include "core/errors/regex_error.h"
/**
 * @brief Free resources associated with a command
 *
 * @param command The command to free
 */
void
rift_command_free(rift_command_t *command)
{
    if (!command) {
        return;
    }

    rift_ast_command_t *cmd = (rift_ast_command_t *)command;

    /* Free command-specific resources */
    if (cmd->options.input_file) {
        rift_free(cmd->options.input_file);
    }

    if (cmd->options.output_file) {
        rift_free(cmd->options.output_file);
    }

    if (cmd->options.format) {
        rift_free(cmd->options.format);
    }

    if (cmd->options.transform_file) {
        rift_free(cmd->options.transform_file);
    }

    if (cmd->options.parse_tree_file) {
        rift_free(cmd->options.parse_tree_file);
    }

    /* Free the command itself */
    rift_free(command);
}
