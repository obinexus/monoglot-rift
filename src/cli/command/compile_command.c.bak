ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
#include "cli/command/compile_command.h"
#include "librift/cli/commands/compile_command.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
/**
 * @file compile_command.c
 * @brief Compile command implementation for LibRift CLI
 *
 * This file implements the compile command, which compiles a regex pattern
 * and optionally saves it to a file for later use.
 *
 * @copyright Copyright (c) 2025 LibRift Project
 * @license MIT License
 */


ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
/**
 * @brief Create a new compile command
 *
 * @return A new compile command instance or NULL on failure
 */
rift_command_t *
rift_compile_command_create(void)
{
    rift_compile_command_t *cmd =
        (rift_compile_command_t *)rift_malloc(sizeof(rift_compile_command_t));
    if (!cmd) {
        return NULL;
    }

    /* Initialize command structure */
    cmd->type = RIFT_COMMAND_COMPILE;
    cmd->verbose = false;
    cmd->quiet = false;

    /* Initialize options with defaults */
    cmd->options.pattern = NULL;
    cmd->options.output_file = NULL;
    cmd->options.use_rift_syntax = false;
    cmd->options.optimize = true;
    cmd->options.use_dfa = true;
    cmd->options.print_ast = false;
    cmd->options.print_automaton = false;
    cmd->options.flags = 0; /* RIFT_REGEX_FLAG_NONE */

    return (rift_command_t *)cmd;
}

ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
/**
 * @brief Get the type of a command
 *
 * @param command The command
 * @return The command type
 */
rift_command_type_t
rift_command_get_type(const rift_command_t *command)
{
    if (!command) {
        return RIFT_COMMAND_UNKNOWN;
    }

    const rift_compile_command_t *cmd = (const rift_compile_command_t *)command;
    return cmd->type;
}

ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
/**
 * @brief Set verbose flag for a command
 *
 * @param command The command
 * @param verbose Whether to enable verbose output
 */
void
rift_command_set_verbose(rift_command_t *command, bool verbose)
{
    if (!command) {
        return;
    }

    rift_compile_command_t *cmd = (rift_compile_command_t *)command;
    cmd->verbose = verbose;
}

ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
/**
 * @brief Set quiet flag for a command
 *
 * @param command The command
 * @param quiet Whether to enable quiet mode
 */
void
rift_command_set_quiet(rift_command_t *command, bool quiet)
{
    if (!command) {
        return;
    }

    rift_compile_command_t *cmd = (rift_compile_command_t *)command;
    cmd->quiet = quiet;
}

ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
/**
 * @brief Get the options for a compile command
 *
 * @param command The compile command
 * @return Pointer to the compile options
 */
rift_compile_options_t *
rift_compile_command_get_options(rift_command_t *command)
{
    if (!command || rift_command_get_type(command) != RIFT_COMMAND_COMPILE) {
        return NULL;
    }

    rift_compile_command_t *cmd = (rift_compile_command_t *)command;
    return &cmd->options;
}

ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
/**
 * @brief Set the options for a compile command
 *
 * @param command The compile command
 * @param options The options to set
 * @return true if successful, false otherwise
 */
bool
rift_compile_command_set_options(rift_command_t *command, const rift_compile_options_t *options)
{
    if (!command || rift_command_get_type(command) != RIFT_COMMAND_COMPILE || !options) {
        return false;
    }

    rift_compile_command_t *cmd = (rift_compile_command_t *)command;

    /* Free existing pattern and output_file if present */
    if (cmd->options.pattern) {
        rift_free(cmd->options.pattern);
    }

    if (cmd->options.output_file) {
        rift_free(cmd->options.output_file);
    }

    /* Copy pattern if present */
    if (options->pattern) {
        cmd->options.pattern = rift_strdup(options->pattern);
        if (!cmd->options.pattern) {
            return false;
        }
    } else {
        cmd->options.pattern = NULL;
    }

    /* Copy output file if present */
    if (options->output_file) {
        cmd->options.output_file = rift_strdup(options->output_file);
        if (!cmd->options.output_file) {
            rift_free(cmd->options.pattern);
            cmd->options.pattern = NULL;
            return false;
        }
    } else {
        cmd->options.output_file = NULL;
    }

    /* Copy the rest of the options */
    cmd->options.use_rift_syntax = options->use_rift_syntax;
    cmd->options.optimize = options->optimize;
    cmd->options.use_dfa = options->use_dfa;
    cmd->options.print_ast = options->print_ast;
    cmd->options.print_automaton = options->print_automaton;
    cmd->options.flags = options->flags;

    return true;
}

ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
/**
 * @brief Execute the compile command
 *
 * @param command The command
 * @return 0 on success, non-zero on failure
 */
int
rift_command_execute(rift_command_t *command)
{
    if (!command) {
        return 1;
    }

    rift_compile_command_t *cmd = (rift_compile_command_t *)command;

    /* Validate options */
    if (!cmd->options.pattern) {
        fprintf(stderr, "Error: No pattern specified\n");
        return 1;
    }

    /* Apply options to flags */
    if (cmd->options.optimize) {
        /* Skip optimization flag for now */
        (void)cmd->options.optimize;
    }

    if (cmd->options.use_dfa) {
        cmd->options.flags |= RIFT_REGEX_FLAG_USE_DFA;
    }

    if (cmd->options.use_rift_syntax) {
        cmd->options.flags |= RIFT_REGEX_FLAG_RIFT_SYNTAX;
    }

    /* Print what we're doing */
    if (cmd->verbose && !cmd->quiet) {
        printf("Compiling pattern: %s\n", cmd->options.pattern);
        printf("Flags: 0x%X\n", cmd->options.flags);
    }

    /* Compile the pattern */
    rift_regex_error_t error;
    rift_regex_error_init(&error); /* Initialize error structure */
    rift_regex_pattern_t *pattern =
        rift_regex_compile(cmd->options.pattern, cmd->options.flags, &error);

    if (!pattern) {
        const char *error_msg = rift_regex_get_error_string(error);
        fprintf(stderr, "Error: Compilation failed: %s\n", error_msg);
        return 1;
    }

    /* Print success message */
    if (!cmd->quiet) {
        printf("Pattern compiled successfully.\n");
        printf("Capture groups: %zu\n", rift_regex_pattern_get_group_count(pattern));
        printf("LibRift syntax: %s\n", rift_regex_pattern_is_rift_syntax(pattern) ? "yes" : "no");
    }

    /* Print AST if requested */
    if (cmd->options.print_ast) {
        const rift_regex_ast_t *ast = rift_regex_pattern_get_ast(pattern);
        if (ast) {
            char *ast_str = rift_regex_ast_to_string(ast);
            if (ast_str) {
                printf("\nAbstract Syntax Tree:\n");
                printf("----------------------\n");
                printf("%s\n", ast_str);
                rift_free(ast_str);
            }
        }
    }

    /* Print automaton if requested */
    if (cmd->options.print_automaton) {
        printf("\nAutomaton:\n");
        printf("----------\n");
        printf("Automaton visualization not implemented yet.\n");
    }

    /* Save to file if specified */
    if (cmd->options.output_file) {
        /* In a real implementation, we would serialize the pattern to the file */
        if (cmd->verbose) {
            printf("Saving pattern to file: %s\n", cmd->options.output_file);
        }

        /* Placeholder for serialization */
        FILE *file = fopen(cmd->options.output_file, "wb");
        if (!file) {
            fprintf(stderr, "Error: Failed to open output file: %s\n", cmd->options.output_file);
            rift_regex_pattern_free(pattern);
            return 1;
        }

        /* Write a simple header for now */
        fprintf(file, "LibRift Compiled Pattern\n");
        fprintf(file, "Pattern: %s\n", cmd->options.pattern);
        fprintf(file, "Flags: 0x%X\n", cmd->options.flags);

        fclose(file);
    }

    /* Clean up */
    rift_regex_pattern_free(pattern);

    return 0;
}

ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
/**
 * @brief Get help information for a command
 *
 * @param command The command
 * @return Help string for the command
 */
const char *
rift_command_get_help(const rift_command_t *command)
{
    if (!command) {
        return "Error: Invalid command";
    }

    rift_command_type_t type = rift_command_get_type(command);

    if (type == RIFT_COMMAND_COMPILE) {
        return "compile <pattern> [options]\n"
               "\n"
               "Compile a regular expression pattern for later use.\n"
               "\n"
               "Arguments:\n"
               "  <pattern>                     Regex pattern to compile\n"
               "\n"
               "Options:\n"
               "  --output, -o <file>           Save compiled pattern to a file\n"
               "  --rift                        Enable LibRift r'' syntax\n"
               "  --no-optimize                 Disable automaton optimization\n"
               "  --nfa                         Force NFA mode (no DFA conversion)\n"
               "  --print-ast                   Print the Abstract Syntax Tree\n"
               "  --print-automaton             Print the automaton structure\n"
               "  --case-insensitive, -i        Case insensitive matching\n"
               "  --multiline, -m               ^ and $ match start/end of line\n"
               "  --dotall, -s                  . matches newline\n"
               "  --extended, -x                Ignore whitespace in pattern\n"
               "\n"
               "Examples:\n"
               "  librift compile \"a(b|c)*\" --output pattern.rre\n"
               "  librift compile r'a(b|c)*' --rift --no-optimize\n"
               "  librift compile \"[0-9]+\" -i -o numbers.rre";
    }

    return "Error: Unknown command type";
}

ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
/**
 * @brief Free resources associated with a command
 *
 * @param command The command to free
 */
void
rift_command_free(rift_command_t *command)
{
    if (!command) {
        return;
    }

    rift_compile_command_t *cmd = (rift_compile_command_t *)command;

    /* Free command-specific resources */
    if (cmd->options.pattern) {
        rift_free(cmd->options.pattern);
    }

    if (cmd->options.output_file) {
        rift_free(cmd->options.output_file);
    }

    /* Free the command itself */
    rift_free(command);
}

ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
ommand/compile_command.h"/a #include "runtime/pattern_complexity_strategy.h"
/**
 * @brief Parse command-specific arguments
 *
 * @param command The command
 * @param argc Argument count
 * @param argv Argument vector
 * @return true if parsing was successful, false otherwise
 */
bool
rift_command_parse_args(rift_command_t *command, int argc, char *argv[])
{
    if (!command) {
        return false;
    }

    rift_compile_command_t *cmd = (rift_compile_command_t *)command;

    /* Must have at least a pattern */
    if (argc < 1) {
        if (!cmd->quiet) {
            fprintf(stderr, "Error: No pattern specified.\n");
        }
        return false;
    }

    /* Set the pattern */
    cmd->options.pattern = rift_strdup(argv[0]);
    if (!cmd->options.pattern) {
        fprintf(stderr, "Error: Failed to allocate memory for pattern\n");
        return false;
    }

    /* Check if pattern uses LibRift r'' syntax */
    if (cmd->options.pattern[0] == 'r' &&
        (cmd->options.pattern[1] == '\'' || cmd->options.pattern[1] == '"')) {
        cmd->options.use_rift_syntax = true;
        cmd->options.flags |= RIFT_REGEX_FLAG_RIFT_SYNTAX;
    }

    /* Parse additional options */
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--output") == 0 || strcmp(argv[i], "-o") == 0) {
            /* Output file */
            if (i + 1 < argc) {
                cmd->options.output_file = rift_strdup(argv[i + 1]);
                if (!cmd->options.output_file) {
                    fprintf(stderr, "Error: Failed to allocate memory for output file\n");
                    return false;
                }
                i++; /* Skip the argument value */
            } else {
                if (!cmd->quiet) {
                    fprintf(stderr, "Error: Missing argument for --output option.\n");
                }
                return false;
            }
        } else if (strcmp(argv[i], "--rift") == 0) {
            /* Enable LibRift r'' syntax */
            cmd->options.use_rift_syntax = true;
            cmd->options.flags |= RIFT_REGEX_FLAG_RIFT_SYNTAX;
        } else if (strcmp(argv[i], "--no-optimize") == 0) {
            /* Disable optimization */
            cmd->options.optimize = false;
            cmd->options.flags &= ~RIFT_REGEX_FLAG_OPTIMIZE_SIZE;
        } else if (strcmp(argv[i], "--nfa") == 0) {
            /* Force NFA mode */
            cmd->options.use_dfa = false;
            cmd->options.flags &= ~RIFT_REGEX_FLAG_OPTIMIZE_SIZE;
        } else if (strcmp(argv[i], "--print-ast") == 0) {
            /* Print AST */
            cmd->options.print_ast = true;
        } else if (strcmp(argv[i], "--print-automaton") == 0) {
            /* Print automaton */
            cmd->options.print_automaton = true;
        } else if (strcmp(argv[i], "--case-insensitive") == 0 || strcmp(argv[i], "-i") == 0) {
            /* Case insensitive */
            cmd->options.flags |= RIFT_REGEX_FLAG_CASE_INSENSITIVE;
        } else if (strcmp(argv[i], "--multiline") == 0 || strcmp(argv[i], "-m") == 0) {
            /* Multiline */
            cmd->options.flags |= RIFT_REGEX_FLAG_MULTILINE;
        } else if (strcmp(argv[i], "--dotall") == 0 || strcmp(argv[i], "-s") == 0) {
            /* Dot matches all */
            cmd->options.flags |= RIFT_REGEX_FLAG_DOTALL;
        } else if (strcmp(argv[i], "--extended") == 0 || strcmp(argv[i], "-x") == 0) {
            /* Extended mode (ignore whitespace) */
            cmd->options.flags |= RIFT_REGEX_FLAG_EXTENDED;
        } else {
            /* Unknown option */
            if (!cmd->quiet) {
                fprintf(stderr, "Warning: Unknown option '%s' ignored.\n", argv[i]);
            }
        }
    }

    return true;
}
