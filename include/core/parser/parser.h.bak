/**
 * @file parser.h
 * @brief Header file for the regex parser component of LibRift
 *
 * This file defines the interface for parsing regular expression patterns
 * in the LibRift regex engine.
 *
 * @copyright Copyright (c) 2025 LibRift Project
 * @license MIT License
 */

#ifndef LIBRIFT_REGEX_PARSER_PARSER_H
#define LIBRIFT_REGEX_PARSER_PARSER_H

#include <ctype.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

#include "core/automaton/automaton.h"
#include "core/automaton/flags.h"
#include "core/engine/pattern.h"
#include "core/errors/regex_error.h"
#include "core/parser/ast.h"
#include "core/parser/ast_node.h"
#include "core/parser/validator.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * Maximum length of error messages generated by the parser
 */
#define RIFT_REGEX_PARSER_MAX_ERROR_LENGTH 256

/**
 * @brief Forward declaration for tokenizer type
 */
typedef struct rift_regex_tokenizer rift_regex_tokenizer_t;

/**
 * @brief Structure representing the LibRift regex parser
 */
typedef struct rift_regex_parser {
    rift_regex_tokenizer_t *tokenizer;   /**< Tokenizer instance */
    rift_regex_validator_t *validator;   /**< Validator instance */
    rift_regex_flags_t flags;            /**< Parser flags */
    rift_regex_ast_t *ast;               /**< Current AST being built */
    rift_regex_ast_node_t *current_node; /**< Current node in AST construction */
} rift_regex_parser_t;

/**
 * Maximum length of error messages generated by the parser
 */
#define RIFT_REGEX_PARSER_MAX_ERROR_LENGTH 256

/**
 * @brief Create a new parser
 *
 * @param flags Parsing flags to initialize with
 * @param rift_flag Whether to enable LibRift syntax mode
 * @return A new parser or NULL on failure
 */
rift_regex_parser_t *rift_regex_parser_create(rift_regex_flags_t flags, bool rift_flag);

/**
 * Forward declarations for recursive descent parsing
 */
static bool parse_atom(rift_regex_parser_t *parser);
static bool parse_term(rift_regex_parser_t *parser);
/**
 * @brief Free resources associated with a parser
 *
 * @param parser The parser to free
 */
void rift_regex_parser_free(rift_regex_parser_t *parser);

/**
 * @brief Parse a regular expression pattern
 *
 * @param parser The parser
 * @param pattern The pattern to parse
 * @return An AST representing the pattern or NULL on failure
 */
rift_regex_ast_t *rift_regex_parser_parse(rift_regex_parser_t *parser, const char *pattern);

/**
 * @brief Parse a regular expression pattern with options
 *
 * @param parser The parser
 * @param pattern The pattern to parse
 * @param flags Flags that affect parsing
 * @return An AST representing the pattern or NULL on failure
 */
rift_regex_ast_t *rift_regex_parser_parse_with_options(rift_regex_parser_t *parser,
                                                       const char *pattern,
                                                       rift_regex_flags_t flags);
/**
 * @brief Get the last error code
 *
 * @param parser The parser
 * @return The error code from the last operation
 */
rift_regex_error_t rift_regex_parser_get_error(const rift_regex_parser_t *parser);
rift_regex_error_t rift_regex_pattern_parser_get_error(const rift_regex_parser_t *parser);

/* @brief Get the position of the last error
 *
 * @param parser The parser
 * @return The position of the last error or (size_t)-1 if no error occurred
 */
size_t rift_regex_parser_get_error_position(const rift_regex_parser_t *parser);

/**
 * @brief Set the tokenizer for the parser
 *
 * Normally, the parser creates a tokenizer internally, but this function
 * allows providing a custom tokenizer for testing or special cases.
 *
 * @param parser The parser
 * @param tokenizer The tokenizer to use
 * @return true if successful, false otherwise
 */
bool rift_regex_parser_set_tokenizer(rift_regex_parser_t *parser,
                                     rift_regex_tokenizer_t *tokenizer);

/**
 * @brief Set the validator for the parser
 *
 * Normally, the parser creates a validator internally, but this function
 * allows providing a custom validator for testing or special cases.
 *
 * @param parser The parser
 * @param validator The validator to use
 * @return true if successful, false otherwise
 */
bool rift_regex_parser_set_validator(rift_regex_parser_t *parser,
                                     rift_regex_validator_t *validator);

/**
 * @brief Handle alternation (|) in the pattern
 *
 * This is a low-level function used primarily for testing.
 *
 * @param parser The parser
 * @return true if successful, false otherwise
 */
bool rift_regex_parser_handle_alternation(rift_regex_parser_t *parser);

/**
 * @brief Handle concatenation (sequence) in the pattern
 *
 * This is a low-level function used primarily for testing.
 *
 * @param parser The parser
 * @return true if successful, false otherwise
 */
bool rift_regex_parser_handle_concatenation(rift_regex_parser_t *parser);

/**
 * @brief Handle quantifier (*, +, ?, {m,n}) in the pattern
 *
 * This is a low-level function used primarily for testing.
 *
 * @param parser The parser
 * @return true if successful, false otherwise
 */
bool rift_regex_parser_handle_quantifier(rift_regex_parser_t *parser);

/**
 * @brief Handle group ((...)) in the pattern
 *
 * This is a low-level function used primarily for testing.
 *
 * @param parser The parser
 * @return true if successful, false otherwise
 */
bool rift_regex_parser_handle_group(rift_regex_parser_t *parser);

/**
 * @brief Handle character class ([...]) in the pattern
 *
 * This is a low-level function used primarily for testing.
 *
 * @param parser The parser
 * @return true if successful, false otherwise
 */
bool rift_regex_parser_handle_character_class(rift_regex_parser_t *parser);

#ifdef __cplusplus
}
#endif

#endif /* LIBRIFT_REGEX_PARSER_PARSER_H */